import numpy as np
from scipy.optimize import curve_fit

import matplotlib.pyplot as plt

from uncertainties import ufloat
from uncertainties.umath import *  # sin(), etc.

fig,ax = plt.subplots()

donnees = np.array([[.5,.1,1.255,.1],
                 [.387,.15,1.25,.15],
                 [.24,.07,1.189,.07],
                 [.136,.2,1.124,.2],
                 [.04,.01,.783,.05],
                 [.011,0.005,.402,0.05]])

n = len(donnees)

x = donnees[:,0] #abscisses des points exp
y = donnees[:,2] #ordonnées des points exp
Deltax =  (donnees[:,1])#incertitudes-types sur x
Deltay = (donnees[:,3]) #incertitudes-types sur y

xmin = np.amin(donnees[:,0])
xmax = np.amax(donnees[:,0])
ymin = np.amin(donnees[:,2])
ymax = np.amax(donnees[:,2])

ax.cla()
ax.set_xlabel('abscisse')
ax.set_ylabel('ordonnée')
ax.set_title('titre')
ax.errorbar(x,y,yerr=Deltay,xerr=Deltax,fmt='bo ',label='données',capsize=3)
ax.legend(loc='best')

fig.show()

def func(x, a, b):
  # a et b seront les paramètres à ajuster
  return a * x / (b + x)

estimations_initiales = ([1.2, 0.03]) #qu'on peut omettre

parametres, pcov = curve_fit(func, x, y, p0=estimations_initiales,sigma=Deltay)
std_parametres = np.sqrt(np.diag(pcov))
nombre_params= len(parametres) # nombre de paramètres

resultats = [ufloat(parametres[i],std_parametres[i]) for i in range(nombre_params)]

for i in range(nombre_params):
  print('p{0} = {1:.3e}'.format(i, resultats[i]))

legende = ''
for i in range(nombre_params):
    legende+='p{0} = {1:.3e}\n'.format(i, resultats[i])

xfit = np.linspace(xmin,xmax)
yfit = func(xfit, *parametres[:])
ax.plot(xfit,yfit,'r',label='fit')
ax.text(.9,.1,legende,transform=ax.transAxes,horizontalalignment='right', verticalalignment='bottom')

# fig.savefig('courbe.png')
